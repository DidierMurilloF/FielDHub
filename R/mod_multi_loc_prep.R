#' multi_loc_preps UI Function
#'
#' @description A shiny Module.
#'
#' @param id,input,output,session Internal parameters for {shiny}.
#'
#' @noRd 
#'
#' @importFrom shiny NS tagList 
mod_multi_loc_preps_ui <- function(id){
  ns <- NS(id)
  tagList(
    h4("Partially Replicated Design"),
    sidebarLayout(
        sidebarPanel(
            width = 4,
            numericInput(
                inputId = ns("gens_prep"), 
                label = "Input # of genotypes:",
                value = 320,
                min = 1
            ),
            radioButtons(
                inputId = ns("include_checks"), 
                label = "Include checks?", 
                choices = c("Yes", "No"), 
                selected = "No",
                inline = TRUE, 
                width = NULL, 
                choiceNames = NULL, 
                choiceValues = NULL
            ),
            conditionalPanel(
                condition = "input.include_checks  == 'Yes'", 
                ns = ns,
                fluidRow(
                    column(
                        width = 6,
                        numericInput(
                            inputId = ns("prep_checks_met"),
                            label = "Input # of Checks:",
                            min = 1,
                            max = 10,
                            value = 3
                        )
                    ),
                    column(
                        width = 6,
                        textInput(
                            inputId = ns("prep_checks"), 
                            label = "Input # Check's Reps:", 
                            value = "8,8,8"
                        )
                    )
                )
            ),
            fluidRow(
                column(
                    width = 6, 
                    numericInput(
                        inputId = ns("locs_prep"), 
                        label = "Input # of Locations:", 
                        value = 6, 
                        min = 1
                    )
                ),
                column(
                    width = 6,
                    selectInput(
                        inputId = ns("loc_to_view_preps"), 
                        label = "Choose Location to View:", 
                        choices = 1:1, 
                        selected = 1,
                        multiple = FALSE
                    )
                )
            ),
            selectInput(
                inputId = ns("plant_copies_preps"), 
                label = "# of Copies Per Plant:",
                choices = 1:6
            ),
            selectInput(
                ns("planter_preps"), 
                label = "Plot Order Layout:",
                choices = c("serpentine", "cartesian"), 
                multiple = FALSE,
                selected = "serpentine"
            ),
            fluidRow(
                column(
                    width = 6,
                    numericInput(
                        ns("seed_preps"), 
                        label = "Seed number:", 
                        value = 1, 
                        min = 1
                    )
                ),
                column(
                    width = 6, 
                    textInput(
                        ns("expt_name_preps"), 
                        "Input Experiment Name:", 
                        value = "Expt1"
                    )
                )
            ),  
            fluidRow(
                column(
                    width = 6, 
                    textInput(
                        ns("plot_start_preps"), 
                        "Starting Plot Number:", 
                        value = 1
                    )
                ),
                column(
                    width = 6, 
                    textInput(
                        ns("loc_name_preps"), 
                        "Input Location Name:", 
                        value = "FARGO"
                    )
                )
            ),
            fluidRow(
                column(
                    width = 6,
                    actionButton(
                        inputId = ns("run_prep"), 
                        label = "Run!", 
                        icon = icon("circle-nodes", verify_fa = FALSE),
                        width = '100%'
                    )
                ),
                column(
                    width = 6,
                    actionButton(
                        ns("simulate_prep_data"), 
                        label = "Simulate!", 
                        icon = icon("greater-than-equal", verify_fa = FALSE),
                        width = '100%'
                    )
                )
            ),
            br(),
            uiOutput(ns("download_prep_avg"))
        ),
        mainPanel(
            width = 8,
            shinyjs::useShinyjs(),
            tabsetPanel(id = ns("tabset_prep_avg"),
            tabPanel("Get Random", value = "tabPanel_prep_avg",
                br(),
                shinyjs::hidden(
                    selectInput(inputId = ns("dimensions_preps"), 
                                label = "Select dimensions of field:", 
                                choices = "")
                ),
                shinyjs::hidden(
                    actionButton(ns("get_random_prep"), label = "Randomize!")
                ),
                br(),
                br(),
                shinycssloaders::withSpinner(
                    DT::DTOutput(ns("prep_allocation")),
                    type = 4
                )
            ),
            #tabPanel("Data Input", DT::DTOutput(ns("dataup.preps"))),
            tabPanel("Randomized Field",
                    shinycssloaders::withSpinner(
                        DT::DTOutput(ns("avg_field_preps")), 
                        type = 4)
                    ),
            tabPanel("Plot Number Field", DT::DTOutput(ns("PREPSPLOTFIELD"))),
            tabPanel("Field Book", DT::DTOutput(ns("pREPSOUTPUT"))),
            tabPanel("Heatmap", plotly::plotlyOutput(ns("heatmap_prep"), width = "97%"))
            )
        )
    )
  )
}
#' multi_loc_preps Server Functions
#'
#' @noRd 
mod_multi_loc_preps_server <- function(id){
  moduleServer( id, function(input, output, session){
    ns <- session$ns

    shinyjs::useShinyjs()

    observe({
        prep_locs <- as.numeric(input$locs_prep)
        start <- prep_locs + 1
        plant_reps <- start:(prep_locs * 2 - 1)
        updateSelectInput(inputId = "plant_copies_preps", 
                            choices = plant_reps, 
                            selected = plant_reps[2])
    })

    prep_inputs <- eventReactive(input$run_prep, {
        if (input$include_checks == "Yes"){
            prep_checks <- as.numeric(as.vector(unlist(strsplit(input$prep_checks, ","))))
            checks <- as.numeric(input$prep_checks_met)
            if (length(prep_checks) != checks) {
                shinyalert::shinyalert(
                    "Error!!", 
                    "Data input needs at least three Columns with the ENTRY and NAME.", 
                    type = "error"
                )
                return(NULL)
            }
        } else {
            prep_checks <- NULL
            checks <- NULL
        }
        planter_mov <- input$planter_preps
        expt_name <- as.character(input$expt_name_preps)
        plotNumber <- as.numeric(as.vector(unlist(strsplit(input$plot_start_preps, ","))))
        site_names <- as.character(as.vector(unlist(strsplit(input$loc_name_preps, ","))))
        seed_number <- as.numeric(input$seed_preps)
        sites = as.numeric(input$locs_prep)
        return(
            list(
                sites = sites, 
                location_names = site_names, 
                seed_number = seed_number, 
                plotNumber = plotNumber,
                planter_mov = planter_mov,
                expt_name = expt_name,
                checks = checks,
                prep_checks = prep_checks
            )
        ) 
    })

    observeEvent(prep_inputs()$sites, {
        loc_user_view <- 1:prep_inputs()$sites
        updateSelectInput(inputId = "loc_to_view_preps", 
                            choices = loc_user_view, 
                            selected = loc_user_view[1])
    })

    # observeEvent(input$input.input_prep_data,
    #              handlerExpr = updateTabsetPanel(session,
    #                                              "tabset_prep_avg",
    #                                              selected = "tabPanel_prep_avg"))

    # observeEvent(input$run_prep,
    #              handlerExpr = updateTabsetPanel(session,
    #                                              "tabset_prep_avg",
    #                                              selected = "tabPanel_prep_avg"))
    
    # get_data_prep <- eventReactive(input$run_prep, {
    #   if (input$input_prep_data == 'Yes') {
    #     req(input$input_file_prep)
    #     inFile <- input$input_file_prep
    #     data_ingested <- load_file(name = inFile$name,
    #                                path = inFile$datapat,
    #                                sep = input$input_file_sep, 
    #                                check = TRUE, 
    #                                design = "prep")
        
    #     if (names(data_ingested) == "dataUp") {
    #       data_up <- data_ingested$dataUp
    #       data_up <- na.omit(data_up)
    #       data_preps <- as.data.frame(data_up)
    #       if (ncol(data_preps) < 3) {
    #         shinyalert::shinyalert(
    #           "Error!!", 
    #           "Data input needs at least three columns with: ENTRY, NAME and REPS.", 
    #           type = "error")
    #         return(NULL)
    #       } 
    #       data_preps <- as.data.frame(data_preps[,1:3])
    #       colnames(data_preps) <- c("ENTRY", "NAME", "REPS")
    #       if(!is.numeric(data_preps$REPS) || !is.integer(data_preps$REPS) ||
    #          is.factor(data_preps$REPS)) validate("'REPS' must be numeric.")
    #       total_plots <- sum(data_preps$REPS)
    #     } else if (names(data_ingested) == "bad_format") {
    #       shinyalert::shinyalert(
    #         "Error!!", 
    #         "Invalid file; Please upload a .csv file.", 
    #         type = "error")
    #       return(NULL)
    #     } else if (names(data_ingested) == "duplicated_vals") {
    #       shinyalert::shinyalert(
    #         "Error!!", 
    #         "Check input file for duplicate values.", 
    #         type = "error")
    #       return(NULL)
    #     } else if (names(data_ingested) == "missing_cols") {
    #       shinyalert::shinyalert(
    #         "Error!!", 
    #         "Data input needs at least three columns with: ENTRY, NAME and REPS.",
    #         type = "error")
    #       return(NULL)
    #     }
    #   } else {
    #     req(input$gens_prep)
    #     req(input$rep_units_prep)
    #     repGens <- as.numeric(as.vector(unlist(strsplit(input$gens_prep, ","))))
    #     repUnits <- as.numeric(as.vector(unlist(strsplit(input$rep_units_prep, ","))))
    #     if (length(repGens) != length(repUnits)) shiny::validate("Input repGens and repUnits must be of the same length.")
    #     ENTRY <- 1:sum(repGens)
    #     NAME <- paste(rep("G", sum(repGens)), 1:sum(repGens), sep = "")
    #     REPS <- sort(rep(repUnits, times = repGens), decreasing = TRUE)
    #     data_preps <- data.frame(list(ENTRY = ENTRY, 
    #                                      NAME = NAME, 
    #                                      REPS = REPS))
    #     colnames(data_preps) <- c("ENTRY", "NAME", "REPS")
    #     total_plots <- sum(data_preps$REPS)
    #   }
    #   return(list(data_up.preps = data_preps, total_plots = total_plots))
    # })
    setup_optim_prep <- reactive({
        req(prep_inputs())
        add_checks <- FALSE
        if (input$include_checks == "Yes") add_checks <- TRUE
        do_optim(
            design = "prep",
            lines = input$gens_prep, 
            l = as.numeric(input$locs_prep), 
            plant_reps = as.numeric(input$plant_copies_preps), 
            add_checks = add_checks,
            checks = prep_inputs()$checks, 
            rep_checks = prep_inputs()$prep_checks,
            seed = prep_inputs()$seed_number,
        )
    }) %>%
        bindEvent(input$run_prep)

    list_input_plots <- eventReactive(input$run_prep, {
        req(prep_inputs())
        if (!is.null(prep_inputs()$prep_checks)) {
            prep_checks <- as.numeric(prep_inputs()$prep_checks)
        } else {
            prep_checks <- 0
        }
        plots_for_treatments <- as.numeric(setup_optim_prep()$size_locations[1])
        total_plots <- plots_for_treatments + sum(prep_checks)
        return(
            list(total_plots = total_plots)
        )
    })
    
    observeEvent(list_input_plots(), {
        req(prep_inputs())
        plots_for_treatments <- as.numeric(setup_optim_prep()$size_locations[1])
        if (!is.null(prep_inputs()$prep_checks)) {
            prep_checks <- as.numeric(prep_inputs()$prep_checks)
        } else {
            prep_checks <- 0
        }
        print(sum(prep_checks))
        total_plots <- plots_for_treatments + sum(prep_checks)
        print(total_plots)
        choices <- factor_subsets(total_plots)$labels
        if (is.null(choices)) {
            sort_choices <- "No options available"
        } else {
            dif <- vector(mode = "numeric", length = length(choices))
            for (option in 1:length(choices)) {
                dims <- unlist(strsplit(choices[[option]], " x "))
                dif[option] <- abs(as.numeric(dims[1]) - as.numeric(dims[2]))
            }
            df_choices <- data.frame(choices = unlist(choices), diff_dim = dif)
            df_choices <- df_choices[order(df_choices$diff_dim, decreasing = FALSE), ]
            sort_choices <- as.vector(df_choices$choices)
        }
        updateSelectInput(inputId = "dimensions_preps",
                            choices = sort_choices,
                            selected = sort_choices[1])
    })
    
    field_dimensions_prep <- eventReactive(input$get_random_prep, {
        if (input$dimensions_preps == "No options available") return(NULL)
        dims <- unlist(strsplit(input$dimensions_preps," x "))
        d_row <- as.numeric(dims[1])
        d_col <- as.numeric(dims[2])
        return(list(d_row = d_row, d_col = d_col))
    })

    randomize_hit_prep <- reactiveValues(times = 0)
 
    observeEvent(input$run_prep, {
      randomize_hit_prep$times <- 0
    })

    user_tries_prep <- reactiveValues(tries_prep = 0)

    observeEvent(input$get_random_prep, {
      user_tries_prep$tries_prep <- user_tries_prep$tries_prep + 1
      randomize_hit_prep$times <- randomize_hit_prep$times + 1
    })

    observeEvent(input$dimensions_preps, {
      user_tries_prep$tries_prep <- 0
    })

    list_to_observe_prep <- reactive({
      list(randomize_hit_prep$times, user_tries_prep$tries_prep)
    })

    observeEvent(list_to_observe_prep(), {
      output$download_prep_avg <- renderUI({
        if (randomize_hit_prep$times > 0 & user_tries_prep$tries_prep > 0) {
          downloadButton(
            ns("downloadData.preps"),
            "Save Experiment",
            style = "width:100%")
        }
      })
    })

    observeEvent(input$run_prep, {
        req(setup_optim_prep())
        shinyjs::show(id = "dimensions_preps")
        shinyjs::show(id = "get_random_prep")
    })

    output$prep_allocation <- DT::renderDT({
        locs <- prep_inputs()$sites
        df <- as.data.frame(setup_optim_prep()$allocation)
        df <- df %>% 
            dplyr::mutate(
                Copies = rowSums(.),
                Avg = round(Copies / locs, 1)
            ) %>%
            dplyr::bind_rows(colSums(.))
        rownames(df) <- c(paste0("Genotype-", 1:(nrow(df) - 1)), "Total")
        DT::datatable(
          df,
          caption = 'Table 1: Genotype Allocation Across Environments.',
          extensions = 'Buttons',
          options = list(
            columnDefs = list(list(className = 'dt-center', targets = "_all")),
            dom = 'Bfrtip',
            scrollY = "350px",
            lengthMenu = list(c(5, 15, -1), c('5', '15', 'All')),
            pageLength = nrow(df),
            buttons = c('copy', 'excel', 'print')
          )
        )
    })
    
    pREPS_reactive <- reactive({
        req(setup_optim_prep())
        req(field_dimensions_prep())
        gen.list <- setup_optim_prep()$list_locs
        nrows <- field_dimensions_prep()$d_row
        ncols <- field_dimensions_prep()$d_col
        niter <- 10000
        prep <- TRUE
        locs_preps <- prep_inputs()$sites
        site_names <- prep_inputs()$location_names
        preps.seed <- prep_inputs()$seed_number
        plotNumber <- prep_inputs()$plotNumber
        movement_planter <- prep_inputs()$planter_mov
        expt_name <- prep_inputs()$expt_name
        locations_preps <- vector(mode = "list", length = locs_preps)
        set.seed(preps.seed)
        for (i in 1:locs_preps) {
            locations_preps[[i]] <- partially_replicated(
                nrows = nrows, 
                ncols = ncols, 
                l = 1, 
                seed = NULL, 
                plotNumber = plotNumber, 
                exptName =  expt_name,
                locationNames = site_names, 
                planter = movement_planter, 
                data = gen.list[[i]] 
            )
        }

        return(locations_preps)

    }) %>% 
      bindEvent(input$get_random_prep)
    
     user_site_selection <- reactive({
       return(as.numeric(input$loc_to_view_preps))
     })
    
    output$avg_field_preps <- DT::renderDataTable({
      test <- randomize_hit_prep$times > 0 & user_tries_prep$tries_prep > 0
      if (!test) return(NULL)
      req(pREPS_reactive())
      selection <- as.numeric(user_site_selection())
      w_map <- pREPS_reactive()[[selection]]$layoutRandom
      checks = as.vector(pREPS_reactive()[[selection]]$genEntries[[1]])
      len_checks <- length(checks)
      colores <- c('royalblue','salmon', 'green', 'orange','orchid', 'slategrey',
                   'greenyellow', 'blueviolet','deepskyblue','gold','blue', 'red')
      
      df <- as.data.frame(w_map)
      
      gens <- as.vector(unlist(pREPS_reactive()[[selection]]$genEntries[[2]]))
      
      rownames(df) <- nrow(df):1
      colnames(df) <- paste0('V', 1:ncol(df))
      options(DT.options = list(pageLength = nrow(df), autoWidth = FALSE, 
                                scrollY = "700px"))
      DT::datatable(df,
                    extensions = 'Buttons', 
                     options = list(dom = 'Blfrtip',
                     scrollX = TRUE,
                     fixedColumns = TRUE,
                     pageLength = nrow(df),
                     scrollY = "620px",
                     class = 'compact cell-border stripe',  rownames = FALSE,
                     server = FALSE,
                     filter = list( position = 'top', clear = FALSE, plain =TRUE ),
                     buttons = c('copy', 'excel'),
                     lengthMenu = list(c(10,25,50,-1),
                                       c(10,25,50,"All")))) %>%
        DT::formatStyle(paste0(rep('V', ncol(df)), 1:ncol(df)),
                    backgroundColor = DT::styleEqual(c(checks), # c(checks,gens)
                                                 c(rep(colores[3], len_checks)) # , rep('yellow', length(gens))
                    )
      )
    })
    
    output$PREPSPLOTFIELD <- DT::renderDT({
      test <- randomize_hit_prep$times > 0 & user_tries_prep$tries_prep > 0
      if (!test) return(NULL)
      req(pREPS_reactive())
      plot_num <- pREPS_reactive()[[user_site_selection()]]$plotNumber
    #   a <- as.vector(as.matrix(plot_num))
    #   len_a <- length(a)
      df <- as.data.frame(plot_num)
      rownames(df) <- nrow(df):1
      colnames(df) <- paste0("V", 1:ncol(df))
      options(DT.options = list(pageLength = nrow(df), autoWidth = FALSE))
      DT::datatable(
        df,
        extensions = 'Buttons', 
        options = list(
            dom = 'Blfrtip',
            scrollX = TRUE,
            fixedColumns = TRUE,
            pageLength = nrow(df),
            scrollY = "620px",
            class = 'compact cell-border stripe', rownames = FALSE,
            server = FALSE,
            filter = list( position = 'top', clear = FALSE, plain = TRUE ),
            buttons = c('copy', 'excel'),
            lengthMenu = list(c(10,25,50,-1),
                                c(10,25,50,"All")))
        
        )
    })

    valsPREP <- reactiveValues(ROX = NULL, ROY = NULL, trail.prep = NULL, minValue = NULL,
                                maxValue = NULL)
    
    simuModal.PREP <- function(failed = FALSE) {
      modalDialog(
        fluidRow(
          column(6, 
                 selectInput(inputId = ns("trailsPREP"), label = "Select One:", 
                             choices = c("YIELD", "MOISTURE", "HEIGHT", "Other")),
          ),
          column(6, 
                 checkboxInput(inputId = ns("heatmap_PREP"), label = "Include a Heatmap", value = TRUE),
          )
        ),
        conditionalPanel("input.trailsPREP == 'Other'", ns = ns,
                         textInput(inputId = ns("OtherPREP"), label = "Input Trial Name:", value = NULL)
        ),
        fluidRow(
          column(6, 
                 selectInput(inputId = ns("ROX.PREP"), "Select the Correlation in Rows:", 
                             choices = seq(0.1, 0.9, 0.1),  selected = 0.5)
          ),
          column(6, 
                 selectInput(inputId = ns("ROY.PREP"), "Select the Correlation in Cols:", 
                             choices = seq(0.1, 0.9, 0.1),  selected = 0.5)
          )
        ),
        fluidRow(
          column(6, 
                 numericInput(inputId = ns("min.prep"), "Input the min value", value = NULL)
          ),
          column(6, 
                 numericInput(inputId = ns("max.prep"), "Input the max value", value = NULL)
                 
          )
        ),
        if (failed)
          div(tags$b("Invalid input of data max and min", style = "color: red;")),
        
        footer = tagList(
          modalButton("Cancel"),
          actionButton(inputId = ns("ok.prep"), "GO")
        )
      )
    }


    get_fieldbook <- reactive({
        # Fix number of locations in the fieldbook
        req(pREPS_reactive())
        field_book <- vector(mode = "list", length = length(pREPS_reactive()))
        iter_by_site <- 1:length(pREPS_reactive())
        for (i in iter_by_site) {
            field_book[[i]] <- pREPS_reactive()[[i]]$fieldBook
        }
        fieldBook <- dplyr::bind_rows(field_book)
        fieldBook$ID <- 1:nrow(fieldBook)
        fieldBook$LOCATION <- rep(1:length(pREPS_reactive()), each = nrow(fieldBook)/length(pREPS_reactive()))
        return(list(fieldBook = fieldBook))
    })
    
    observeEvent(input$simulate_prep_data, {
      req(get_fieldbook()$fieldBook)
      test <- randomize_hit_prep$times > 0 & user_tries_prep$tries_prep > 0
      if (test) {
        showModal(
          shinyjqui::jqui_draggable(
            simuModal.PREP()
          )
        )
      }
    })
    
    observeEvent(input$ok.prep, {
      req(input$min.prep, input$max.prep)
      if (input$max.prep > input$min.prep & input$min.prep != input$max.prep) {
        valsPREP$maxValue <- input$max.prep
        valsPREP$minValue  <- input$min.prep
        valsPREP$ROX <- as.numeric(input$ROX.PREP)
        valsPREP$ROY <- as.numeric(input$ROY.PREP)
        if(input$trailsPREP == "Other") {
          req(input$OtherPREP)
          if(!is.null(input$OtherPREP)) {
            valsPREP$trail.prep <- as.character(input$OtherPREP)
          }else showModal(simuModal.PREP(failed = TRUE))
        }else {
          valsPREP$trail.prep <- as.character(input$trailsPREP)
        }
        removeModal()
      }else {
        showModal(
          shinyjqui::jqui_draggable(
            simuModal.PREP(failed = TRUE)
          )
        )
      }
    })
    
    simuDataPREP <- reactive({
      req(pREPS_reactive())
      req(prep_inputs())
      if(!is.null(valsPREP$maxValue) & !is.null(valsPREP$minValue) & !is.null(valsPREP$trail.prep)) {
        maxVal <- as.numeric(valsPREP$maxValue)
        minVal <- as.numeric(valsPREP$minValue)
        ROX_PREP <- as.numeric(valsPREP$ROX)
        ROY_PREP <- as.numeric(valsPREP$ROY)
        df.prep <- get_fieldbook()$fieldBook
        loc_levels_factors <- levels(factor(df.prep$LOCATION, unique(df.prep$LOCATION)))
        locs <- prep_inputs()$sites
        nrows_prep <- field_dimensions_prep()$d_row
        ncols_prep <- field_dimensions_prep()$d_col
        seed_prep <- prep_inputs()$seed_number
        df.prep_list <- vector(mode = "list", length = locs)
        dfSimulationList <- vector(mode = "list", length = locs)
        w <- 1
        set.seed(seed_prep)
        for (sites in 1:locs) {
          df_loc <- subset(df.prep, LOCATION == loc_levels_factors[w])
          fieldBook <- df_loc[, c(1,6,7,9)]
          dfSimulation <- AR1xAR1_simulation(nrows = nrows_prep, ncols = ncols_prep, ROX = ROX_PREP, ROY = ROY_PREP, 
                                             minValue = minVal, maxValue = maxVal, fieldbook = fieldBook, 
                                             trail = valsPREP$trail.prep, seed = NULL)
          
          dfSimulation <- dfSimulation$outOrder
          dfSimulationList[[sites]] <- dfSimulation
          dataPrep <- df_loc
          df_prep <- cbind(dataPrep, round(dfSimulation[,7],2))
          colnames(df_prep)[11] <- as.character(valsPREP$trail.prep)
          df.prep_list[[sites]] <- df_prep
          w <- w + 1
        }
        df.prep_locs <- dplyr::bind_rows(df.prep_list)
        v <- 1
      }else {
        dataPrep <- get_fieldbook()$fieldBook
        v <- 2
      }
      if (v == 1) {
        return(list(df = df.prep_locs, dfSimulationList = dfSimulationList))
      }else if (v == 2) {
        return(list(df = dataPrep))
      }
    })

    heat_map_prep <- reactiveValues(heat_map_option = FALSE)
    
    observeEvent(input$ok.prep, {
      req(input$min.prep, input$max.prep)
      if (input$max.prep > input$min.prep & input$min.prep != input$max.prep) {
        heat_map_prep$heat_map_option <- TRUE
      }
    })
    
    observeEvent(heat_map_prep$heat_map_option, {
      if (heat_map_prep$heat_map_option == FALSE) {
        hideTab(inputId = "tabset_prep_avg", target = "Heatmap")
      } else {
        showTab(inputId = "tabset_prep_avg", target = "Heatmap")
      }
    })
    
    heatmap_obj <- reactive({
      req(simuDataPREP()$dfSimulationList)
      loc_user <- user_site_selection()
      if(input$heatmap_PREP) {
        w <- as.character(valsPREP$trail.prep)
        df <- simuDataPREP()$dfSimulationList[[loc_user]]
        df <- as.data.frame(df)
        p1 <- ggplot2::ggplot(df, ggplot2::aes(x = df[,4], y = df[,3], fill = df[,7], text = df[,8])) + 
          ggplot2::geom_tile() +
          ggplot2::xlab("COLUMN") +
          ggplot2::ylab("ROW") +
          ggplot2::labs(fill = w) +
          viridis::scale_fill_viridis(discrete = FALSE)
        
        p2 <- plotly::ggplotly(p1, tooltip="text", height = 700)
        return(p2)
      }
    }) 
    
    output$heatmap_prep <- plotly::renderPlotly({
      test <- randomize_hit_prep$times > 0 & user_tries_prep$tries_prep > 0
      if (!test) return(NULL)
      req(heatmap_obj())
      heatmap_obj()
    }) 
    
    
    output$pREPSOUTPUT <- DT::renderDT({
      test <- randomize_hit_prep$times > 0 & user_tries_prep$tries_prep > 0
      if (!test) return(NULL)
      df <- simuDataPREP()$df
      df$EXPT <- as.factor(df$EXPT)
      df$LOCATION <- as.factor(df$LOCATION)
      df$PLOT <- as.factor(df$PLOT)
      df$ROW <- as.factor(df$ROW)
      df$COLUMN <- as.factor(df$COLUMN)
      df$CHECKS <- as.factor(df$CHECKS)
      df$ENTRY <- as.factor(df$ENTRY)
      df$TREATMENT <- as.factor(df$TREATMENT)
      options(DT.options = list(pageLength = nrow(df), autoWidth = FALSE,
                                scrollX = TRUE, scrollY = "500px"))
      DT::datatable(df, 
                    filter = "top",
                    rownames = FALSE, 
                    options = list(
                      columnDefs = list(list(className = 'dt-center', targets = "_all")))
      )
    })
    
    output$downloadData.preps <- downloadHandler(
      filename = function() {
        req(input$loc_name_preps)
        loc <- input$loc_name_preps
        loc <- paste(loc, "_", "pREP_", sep = "")
        paste(loc, Sys.Date(), ".csv", sep = "")
      },
      content = function(file) {
        write.csv(simuDataPREP()$df, file, row.names = FALSE)
      }
    )
 
  })
}
