#' @title  Generate the sparse allocation 
#'
#' @param design Type of experimental design. It can be \code{prep} or \code{sparse}
#' @param lines Number of genotypes, experimental lines or treatments.
#' @param l Number of locations or sites. By default  \code{l = 1}.
#' @param plant_reps Number of copies per plant. 
#' When design is \code{sparse} then \code{plant_reps} < \code{l}
#' @param checks Number of genotypes checks. 
#' @param rep_checks Replication for each check.
#' @param data A dataframe with the ENTRIES and NAMES
#' @param seed (optional) Real number that specifies the starting seed to obtain reproducible designs.
#' 
#' @examples 
#' sparse_example <- do_optim(
#'    design = "sparse",
#'    lines = 320, 
#'    l = 5, 
#'    plant_reps = 4, 
#'    checks = 4, 
#'    seed = 15
#' )
#' @export 
do_optim <- function(design = "prep", lines, l, plant_reps, checks, rep_checks, data, seed) {
    # You can change: searches & jumps
    optim_blocks <- blocksdesign::blocks(
        treatments = lines, 
        replicates = plant_reps, 
        blocks = l, 
        searches = 10, 
        seed = seed
    )
    allocation <- table(optim_blocks$Design$treatments, optim_blocks$Design$Level_1)
    allocation_df <- as.data.frame.matrix(allocation)
    colnames(allocation_df) <- paste0("LOC", 1:l)
    col_sum <- base::colSums(allocation_df)
    # Create a wide data frame with number of copies and average per plant
    wide_allocation <- allocation_df %>%
        dplyr::mutate(
        copies = rowSums(.),
        avg = copies / l
        )
    # Create a long data frame with the allocations per location
    long_allocation <- as.data.frame(allocation) %>%
        dplyr::rename_with(~c("ENTRY", "LOCATION", "REPS"), dplyr::everything()) %>%  # rename columns
        dplyr::mutate(
        LOCATION = gsub("B", "LOC", LOCATION),
        NAME = paste0("G-", ENTRY)
        ) %>%  
        dplyr::select(LOCATION, ENTRY, NAME, REPS)
    # Create a data frame for the checks
    max_entry <- lines # Checks start at the last entry + 1 in the data frame
    if (design != "prep") {
        df_checks <- data.frame(
            ENTRY = (max_entry + 1):((max_entry + checks)), 
            NAME = paste0("CH-", (max_entry + 1):((max_entry + checks)))
        )
    } else {
        df_checks <- data.frame(
            ENTRY = (max_entry + 1):((max_entry + checks)), 
            NAME = paste0("CH-", (max_entry + 1):((max_entry + checks))),
            REPS = rep_checks
        )
    }
    # Create a space in memory for the locations data entry list
    list_locs <- setNames(
        object = vector(mode = "list", length = l), 
        nm = unique(long_allocation$LOCATION)
    )
    # Generate the lists of entries for each location
    for (site in unique(long_allocation$LOCATION)) {
        df_loc <- long_allocation %>% 
        dplyr::filter(LOCATION == site, REPS > 0) %>% 
        dplyr::mutate(ENTRY = as.numeric(ENTRY)) %>% 
        dplyr::select(ENTRY, NAME, REPS) %>%
        dplyr::bind_rows(df_checks) %>%
        dplyr::arrange(dplyr::desc(ENTRY))
        
        list_locs[[site]] <- df_loc
    }
    out <- list(
        list_locs = list_locs,
        allocation = allocation_df, 
        size_locations = col_sum
    )
    class(out) <- "Sparse"
    return(out)
}

#' @title  Sparse allocation 
#' Spatial Un-replicated Diagonal Arrangement Design
#' 
#' Randomly generates a spatial un-replicated design using sparse allocation.
#'
#' @param checks_allocation Way to allocate the checks in the field. It can be
#' \code{diagonal} or \code{randomly}
#' @param lines Number of genotypes, experimental lines or treatments.
#' @param checks Number of genotypes checks. 
#' @param planter Option for \code{serpentine} or \code{cartesian} plot arrangement. 
#' By default  \code{planter = 'serpentine'}.
#' @param l Number of locations or sites. By default  \code{l = 1}.
#' @param plotNumber Numeric vector with the starting plot number for each location. 
#' By default \code{plotNumber = 101}.
#' @param plant_reps Number of copies per plant. 
#' When design is \code{sparse} then \code{plant_reps} < \code{l}
#' @param exptName (optional) Name of the experiment.
#' @param locationNames (optional) Names each location.
#' @param nrows Number of rows in the field. 
#' @param ncols Number of columns in the field.
#' @param sparse_list (optional) A class "Sparse" object generated by \code{do_optim()} function.
#' @param seed (optional) Real number that specifies the starting seed to obtain reproducible designs.
#' 
#' @author Didier Murillo [aut],
#'         Salvador Gezan [aut],
#'         Ana Heilman [ctb],
#'         Thomas Walk [ctb], 
#'         Johan Aparicio [ctb], 
#'         Richard Horsley [ctb]
#' @examples
#' sparse <- sparse_allocation(
#' checks_allocation = "diagonal",
#'   lines = 380, 
#'   nrows = 16, 
#'   ncols = 22, 
#'   l = 6, 
#'   plant_reps = 5, 
#'   checks = 4, 
#'   locationNames = c("LOC1", "LOC2", "LOC3", "LOC4", "LOC5", "LOC6"), 
#'   seed = 1234
#' )
#' @export 
sparse_allocation <- function(
    checks_allocation,
    lines, 
    nrows, 
    ncols, 
    l, 
    planter, 
    plotNumber,  
    plant_reps, 
    checks, 
    exptName, 
    locationNames,
    sparse_list, 
    seed) {
    # Check if the reps per plant are mising
    if (missing(plant_reps)) {
        stop("You must specify the number of reps per plant")
    }

    if (!missing(sparse_list)) {
        if (!inherits(sparse_list, "Sparse")) {
            stop("sparse_list must be an object of class 'Sparse'")
        }
        unrep <- sparse_list
    } else {
        unrep <- do_optim(
            design = "sparse",
            lines = lines, 
            l = l, 
            plant_reps = plant_reps, 
            checks = checks, 
            seed = seed
        )
    }

    if (missing(nrows) || missing(ncols)) {
        lines_within_loc <- as.numeric(unrep$size_locations[1])
        print(lines_within_loc)
        t1 <- floor(lines_within_loc + lines_within_loc * 0.11)
        t2 <- ceiling(lines_within_loc + lines_within_loc * 0.20)
        t <- t1:t2
        non_primes <- t[-numbers::isPrime(t)]
        choices_list <- list()
        i <- 1
        for (n in non_primes) {
            choices_list[[i]] <- factor_subsets(n, diagonal = TRUE)$labels
            i <- i + 1
        }
        choices <- unlist(choices_list[!sapply(choices_list, is.null)])
        dif <- vector(mode = "numeric", length = length(choices))
        for (option in 1:length(choices)) {
            dims <- unlist(strsplit(choices[[option]], " x "))
            dif[option] <- abs(as.numeric(dims[1]) - as.numeric(dims[2]))
        }
        df_choices <- data.frame(choices = choices, diff_dim = dif)
        df_choices <- df_choices[order(df_choices$diff_dim, decreasing = FALSE), ]
        dimensions <- unlist(strsplit(df_choices[1,1], " x "))
        nrows <- as.numeric(dimensions[1])
        ncols <- as.numeric(dimensions[2])
    }
    # Create a space in memory for the unrep randomizations
    unrep_designs <- setNames(
        object = vector(mode = "list", length = l), 
        nm = names(unrep$list_locs)
    )
    for (site in names(unrep$list_locs)) {
        df_loc <- unrep$list_locs[[site]] %>% 
        dplyr::mutate(ENTRY = as.numeric(ENTRY)) %>% 
        dplyr::select(ENTRY, NAME)
        unrep_designs[[site]] <- diagonal_arrangement(
            nrows = nrows, 
            ncols = ncols, 
            checks = checks, 
            data = df_loc
        )
    }
    return(
        list(
            designs = unrep_designs, 
            list_locs = unrep$list_locs, 
            allocation = unrep$allocation, 
            size_locations = unrep$size_locations
        )
    )
}